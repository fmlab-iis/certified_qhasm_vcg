#!/usr/bin/env python3

"""
This script identifies flag chains in bvDSL programs. For each

bvAddC flag v e0 e1;     or
bvAdcC flag v e0 e1 flag'

it checks if the value of flag is always zero. If so, it prints

bvAdd v e0 e1; bvAssign flag 0; or
bvAdc v e0 e1 flag'; bvAssign flag 0

Otherwise, it prints the original instruction.

The input COQ.v file should be generated by to_bvdsl and of the
following form:

(* COQ headers from to_bvdsl *)

Definition CUT_INPUTS : VS.t := ...

Definition CUT_PRECOND : bexp := ...

Definition PROGRAM := ... (* from to_bvdsl *)

Let VERIFY_PATH be the path to 'verify' script and FLAG the 
name of flag (such as carry or overflow). To invoke the sceipt, 
do:

cut_chains.py COQ.v VERIFY_PATH CUT_INPUTS CUT_PRECOND PROGRAM FLAG

"""

import sys
import re
import tempfile
import os
import shutil
import subprocess

MAGIC_NUMBER = 31415926
TIMEOUT = 600

bvdsl_insts = [ ("bvAddC", "bvAdd"), ("bvAdcC", "bvAdc") ]

def get_flag_id (line, flag, flag_id):
    ret = re.match ("\s*let\s+" + flag + "\s*:=\s*([0-9]+)", line)
    if (ret):
        return ret.group(1)
    else:
        return flag_id
        

def is_add (flag, line):
    for inst in bvdsl_insts:
        if (re.match (inst[0], line)):
            pattern = re.match ("\s*" + inst[0] + "\s+" + flag, line)
            if (pattern):
                return (inst, pattern.group (0))
            pattern = re.match ("\s*" + inst[0] + "\s+(\s*" + flag + "\s*)",
                                line)
            if (pattern):
                return (inst, pattern.group (0))
    return False

def prepare_coqtempf (current, coqtempf):
    for line in current:
        coqtempf.write (line)

def write_coqtempf (inputs, precond, prog, flag, flag_id, coqtempf):
    coqtempf.write ("] .\n")
    coqtempf.write ("Definition check_flag_post : bexp :=\n")
    coqtempf.write ("let " + flag + " := " + str (flag_id) + " in\n")
    coqtempf.write ("bvands2 [::]\n")
    coqtempf.write ("        [:: (bvrvar " + flag + ") <=r (bvposz 0%Z) ] .\n")
    coqtempf.write ("Definition check_flag_spec :=\n")
    coqtempf.write ("{| spre := " + precond + ";\n")
    coqtempf.write ("  sprog := " + prog + ";\n")
    coqtempf.write ("  spost := check_flag_post |} .\n")
    coqtempf.write ("Lemma valid_check_flag :\n")
    coqtempf.write ("  bvSSA.bv64SSA.valid_rspec (bvSSA2zSSA.bv2z_spec_rng\n")
    coqtempf.write ("    (bvSSA.ssa_spec check_flag_spec)) .\n")
    coqtempf.write ("Proof .\n")
    coqtempf.write ("verify_spec_rng_with (oconf [::]) " + inputs + ".\n")
    coqtempf.write ("Qed .\n")
    coqtempf.write ("Close Scope bvdsl_scope .\n")
    coqtempf.write ("Close Scope N_scope .\n")

def mk_note (flag, line, new_line):
    return [ "(* " + line.replace ("\n", "") + " *)\n",
             "(* NOTE: ignore " + flag + " because it is zero *)\n",
             new_line,
             "bvAssign " + flag + " (bvConst (fromPosZ 0%Z));\n" ]

def mk_timeout_note (flag, line):
    return [ "(* NOTE: timeout while checking " + flag + " is zero *)\n",
             line ]

def clean_up (temppath):
    if (os.path.exists (temppath.replace (".v", ".vo"))):
        os.remove (temppath.replace (".v", ".vo"))
    if (os.path.exists (temppath.replace (".v", ".glob"))):
        os.remove (temppath.replace (".v", ".glob"))
    basetemppath = os.path.basename (temppath)
    if (os.path.exists (basetemppath.replace (".v", ".log"))):
        os.remove (basetemppath.replace (".v", ".log"))

def check_add (verify_cmd, inputs, precond, prog, flag,
               inst, pattern, line, current, flag_id):
    coqtempf = tempfile.NamedTemporaryFile (mode="w",suffix=".v")
    prepare_coqtempf (current, coqtempf)
    coqtempf.flush ()
    coqtempf.write (line.replace (";", ""))
    write_coqtempf (inputs, precond, prog, flag, flag_id, coqtempf)
    coqtempf.flush ()
    proc = subprocess.Popen ([verify_cmd, coqtempf.name])
    try:
        verify_ret = proc.wait (timeout=TIMEOUT)
    except subprocess.CalledProcessError as e:
        verify_ret = e.returncode
    except subprocess.TimeoutExpired:
        proc.terminate ()
        verify_ret = MAGIC_NUMBER
    clean_up (coqtempf.name)
    coqtempf.close ()
    if (verify_ret == 0):
        new_line = line.replace (pattern, inst[1])
        return mk_note (flag, line, new_line)
    elif (verify_ret == MAGIC_NUMBER):
        return mk_timeout_note (flag, line)
    else:
        return [ line ]
    
def cut_chains (fd, verify_cmd, inputs, precond, prog, flag):
    current = [ ]
    flag_id = MAGIC_NUMBER
    for line in fd:
        flag_id = get_flag_id (line, flag, flag_id)
        need_check = is_add (flag, line)
        if (need_check):
            (inst, pattern) = need_check
            new_lines = check_add (verify_cmd, inputs, precond, prog, flag,
                                   inst, pattern, line, current, flag_id)
            for new_line in new_lines:
                print (new_line.replace ("\n", ""))
                current.append (new_line)
        else:
            print (line.replace ("\n", ""))
            current.append (line)

def main ():
    if (len(sys.argv) == 7):
        fd = open (sys.argv[1], "r")
        verify_cmd = sys.argv[2]
        inputs = sys.argv[3]
        precond = sys.argv[4]
        prog = sys.argv[5]
        flag = sys.argv[6]
        cut_chains (fd, verify_cmd, inputs, precond, prog, flag)
        fd.close ()
    else:
        print ("Wrong number of arguments.")
        print ("Usage: python " + sys.argv[0] + " <COQ file> <verify cmd> <inputs> <precondition> <program> <flag>")

if __name__ == "__main__":
  main()
