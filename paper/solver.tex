
Observe that the modular polynomial equation entailment problem is to
decide whether for every $\vx \in \bbfZ^{|\vx|}$,
\[
  \bigwedge\limits_i e_i (\vx) = e'_i (\vx) \wedge
  \bigwedge\limits_j f_j (\vx) \equiv f'_j (\vx) \mod n_j
  \implies
  \bigwedge\limits_k g_k (\vx) = g'_k (\vx) \wedge
  \bigwedge\limits_l   h_l (\vx) \equiv h'_l (\vx) \mod m_l
\]
with 
$e_i (\vx), e'_i (\vx), f_j (\vx), f'_j (\vx),
 g_k (\vx), g'_k (\vx), h_l (\vx), h'_l (\vx) \in \bbfZ[\vx]$
for every $i, j, k, l$.

By
Theorem~\ref{theorem:program-to-q-soundness}, it remains to establish
that for every $\vec{x} \in \bbfZ^{|\vec{x}|}$, 
\[
  \bigwedge\limits_i e_i (\vec{x}) = e'_i (\vec{x}) \wedge
  \bigwedge\limits_j f_j (\vec{x}) \equiv f'_j (\vec{x}) \mod n_j
  \implies
  \bigwedge\limits_k g_k (\vec{x}) = g'_k (\vec{x}) \wedge
  \bigwedge\limits_l   h_l (\vec{x}) \equiv h'_l (\vec{x}) \mod m_l
\]
where
$e_i (\vec{x}), e'_i (\vec{x}), f_j (\vec{x}), f'_j (\vec{x}),
 g_k (\vec{x}), g'_k (\vec{x}), h_l (\vec{x}), h'_l (\vec{x})$
are multivariant polynomials over $\vec{x}$, and
$n_j, m_l \in \bbfN $. Since the conclusion is a conjunction of
(modulo) equations, we will prove one conjunct at a time. That is, for
every $\vec{x} \in \bbfZ^{|\vec{x}|}$, 
\[
  \bigwedge\limits_i e_i (\vec{x}) = e'_i (\vec{x}) \wedge
  \bigwedge\limits_j f_j (\vec{x}) \equiv f'_j (\vec{x}) \mod n_j
  \implies
  g (\vec{x}) = g' (\vec{x})
\] where $g (\vec{x})$ and $g' (\vec{x})$ are multivariant polynomials
over $\vec{x}$. Or,
\[
  \bigwedge\limits_i e_i (\vec{x}) = e'_i (\vec{x}) \wedge
  \bigwedge\limits_j f_j (\vec{x}) \equiv f'_j (\vec{x}) \mod n_j
  \implies
  h (\vec{x}) \equiv h' (\vec{x}) \mod m
\] where $h (\vec{x})$ and $h' (\vec{x})$ are multivariant polynomials
over $\vec{x}$ and $m \in \bbfN$.

Consider the following system of $r + s$ (modulo) equations:
\begin{equation}
  \label{equation:modulo-polynomials}
  \begin{array}{rclcrcl}
    e_1 (\vx) & = & e'_1 (\vx) 
    & \hspace{.05\textwidth} &
    f_1 (\vx) & \equiv & f'_1 (\vx) \mod n_1\\
    & \vdots & & & & \vdots \\
    e_i (\vx) & = & e'_i (\vx) & &
    f_j (\vx) & \equiv & f'_j (\vx) \mod n_j\\
    & \vdots & & & & \vdots \\
    e_r (\vx) & = & e'_r (\vx) & &
    f_s (\vx) & \equiv & f'_s (\vx) \mod n_s
  \end{array}
\end{equation}
Our goal is to establish $g (\vx) = g' (\vx)$ or $h (\vx)
\equiv h (\vx) \mod m$ for every $\vx$ satisfying the system
of equations~(\ref{equation:modulo-polynomials}). In order to prove it
in \coq, we first rewrite modulo equations $f_j (\vx) \equiv f'_j
(\vx) \mod n_j$ to existentially quantified equations $\exists d_j
\in \bbfZ, f_j (\vx) = f'_j (\vx) + n_j \times d_j$. In other
words, we want to show that for every $\vx \in \bbfZ^{|\vx|}$
satisfying 
\begin{equation}
  \label{equation:polynomials}
  \begin{array}{rclcrcl}
    e_1 (\vx) & = & e'_1 (\vx) 
    & \hspace{.05\textwidth} &
    f_1 (\vx) & = & f'_1 (\vx) + n_1 \times d_1 \\
    & \vdots & & & & \vdots \\
    e_i (\vx) & = & e'_i (\vx) & &
    f_j (\vx) & = & f'_j (\vx) + n_j \times d_j \\
    & \vdots & & & & \vdots \\
    e_r (\vx) & = & e'_r (\vx) & &
    f_s (\vx) & = & f'_s (\vx) + n_s \times d_s
  \end{array}
\end{equation}
with some $d_1, \ldots, d_s$, then $g (\vx) = g' (\vx)$ or $h
(\vx) \equiv h' (\vx) \mod m$. 

Consider the 
\emph{polynomial equation entailment} problem which decides whether
\[
\forall \vx. \bigwedge\limits^m_{i=1} e_i(\vx) = 0
             \implies \exists y_1, y_2, \ldots, y_n.
             p_1(\vx) y_1 + p_2(\vx) y_2 + \cdots + p_n(\vx) y_n = a(\vx)
\]
where $e_i(\vx), p_j(\vx), a(\vx) \in \bbfZ[\vx]$ are given for $i =
1, \ldots, m$ and $j = 1, \ldots, n$~\cite{H:07:AENTP}.

There are two \coq tactics to
construct formal proofs. The tactic \dslcode{nsatz} is able to prove
equalities in integral domains. The tactic \dslcode{gbarith} is able
to prove modulo equalities in integral domains. We hence define a
\coq tactic which invokes \dslcode{nsatz} or \dslcode{gbarith} when
it tries to prove $g (\vx) = g' (\vx)$ or $h (\vx) \equiv
h' (\vx) \mod m$ respectively.

The tactics \dslcode{nsatz} and \dslcode{gbarith} however are not very
scalable. \todo{explain briefly} 
For modulo arithmetic over large finite fields, their 
implementations can have hundreds of polynomial equations
in~\ref{equation:polynomials}. The \coq tactics are unable to finish
the proof in a reasonable amount of time. A more scalable tactic is
necessary to verify implementations of low-level cryptographic codes.

For the polynomial equations generated by \textit{ProgramToQ}
($p$) (Algorithm~\ref{algorithm:programtoq}), they are of the
following forms: $x = E$ (from an assignment statement) or $x + 2^c y
= E$ (from a \dslcode{Split} statement). Such polynomial equations can
safely be removed after every occurrences of $x$ are replaced with $E$
or $E - 2^c y$. The number of polynomial equations is thus greatly
reduced. We hence define a \coq tactic to rewrite variables and then
remove corresponding polynomial equations. For proving a polynomial
equation $g (\vx) = g' (\vx)$, it turns out that the \coq tactic
\dslcode{ring} suffices. For a modulo equation $h (\vx) \equiv
h' (\vx) \mod m$, \todo{we need what?}
