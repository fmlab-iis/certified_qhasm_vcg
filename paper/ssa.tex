
\begin{definition}
  A program is in \emph{single static assignment} form if every
  variable is never defined twice (or more).
\end{definition}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAE}{$\theta$, $e$}
    \Match{$e$}
      \Case{$V$} \Return $e^{\theta(e)}$ \EndCase
      \Case{$Z$} \Return $e$ \EndCase
      \Case{$-e'$} \Return $-$\Call{SSAE}{$\theta$, $e'$} \EndCase
      \Case{$e' + e''$} 
        \Return \Call{SSAE}{$\theta$, $e'$} $+$ 
                \Call{SSAE}{$\theta$, $e''$}
      \EndCase
      \Case{$e' - e''$} 
        \Return \Call{SSAE}{$\theta$, $e'$} $-$ 
                \Call{SSAE}{$\theta$, $e''$}
      \EndCase
      \Case{$e' \times e''$} 
        \Return \Call{SSAE}{$\theta$, $e'$} $\times$ 
                \Call{SSAE}{$\theta$, $e''$}
      \EndCase
      \Case{$\dslcode{Pow}$($e'$, $n$)}
        \Return $\dslcode{Pow}$(\Call{SSAE}{$\theta$, $e'$}, $n$)
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Single Static Assignment Transformation for Expressions}
\end{algorithm}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAQ}{$\theta$, $q$}
    \Match{$q$}
      \Case{$\top$} \Return $\top$ \EndCase
      \Case{$e' = e''$} 
        \Return \Call{SSAE}{$\theta$, $e$} = \Call{SSAE}{$\theta$, $e'$}
      \EndCase
      \Case{$e' \equiv e'' \mod n$} 
        \Return \Call{SSAE}{$\theta$, $e$} $\equiv$ 
                \Call{SSAE}{$\theta$, $e'$} $\mod n$
      \EndCase
      \Case{$q' \wedge q''$}
        \Return \Call{SSAQ}{$\theta$, $q'$} $\wedge$
                \Call{SSAQ}{$\theta$, $q''$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Single Static Assignment Transformation for Predicates}
\end{algorithm}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAStatement}{$\theta$, $s$}
    \Match{$s$}
      \Case{$v \leftarrow e$}
        \Return $\theta[v \mapsto \theta(v) + 1]$, 
                $v^{\theta(v) + 1} \leftarrow$ \Call{SSAE}{$\theta$, $e$}
      \EndCase
      \Case{$v_h, v_l \leftarrow \dslcode{Split}(e, n)$}
        \State{\Return $\theta[v_h \mapsto \theta(v_h) + 1]
                       [v_l \mapsto \theta(v_l) + 1]$,
                $v_h^{\theta(v_h) + 1}, v_l^{\theta(v_l) + 1} \leftarrow
                \dslcode{Split}($\Call{SSAE}{$\theta$, $e$}$, n)$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Single Static Assignement Transformation for Statements}
\end{algorithm}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{SSAProgram}{$\theta$, $p$}
    \Match{$p$}
      \Case{$\epsilon$}
        \Return $\theta$, $\epsilon$
      \EndCase
      \Case{$s; pp$}
        \State{$\theta', s' \leftarrow$ 
                 \Call{SSAStatement}{$\theta$, $s$}}
        \State{$\theta'', pp'' \leftarrow$ 
                 \Call{SSAProgram}{$\theta'$, $pp$}}
        \State{\Return $\theta''$, $s'; pp''$}
      \EndCase
    \EndMatch
    \EndFunction
  \end{algorithmic}
  \caption{Single Static Assignment for Programs}
\end{algorithm}

\begin{theorem}
  Let $\theta_0(v) = 0$ for every $v \in V$ and $p \in P$.
  If $\hat{\theta}, \hat{p} = \textsc{SSAProgram}(\theta_0, p)$, then
  $\hat{p}$ is in single static assignment form.
\end{theorem}

\begin{theorem}
  Let $\theta_0(v) = 0$ for every $v \in V$. For every $q, q' \in Q$
  and $p \in P$,
  \begin{center}
    $\cond{q}$ $p$ $\cond{q'}$ if and only if
    $\cond{\textmd{\textit{SSAQ}}(\theta_0, q)}$
    $\hat{p}$
    $\cond{\textmd{\textit{SSAQ}}(\hat{\theta}, q')}$
  \end{center}
  where $\hat{\theta}, \hat{p} =
  \textmd{\textit{SSAProgram}}(\theta_0, p)$.
\end{theorem}