 
The operator $+_{\bbfG}$ is defined by arithmetic computation over
$\bbfF$. In order to compute $p_0 +_{\bbfG} p_1$ for $p_0, p_1 \in G$,
arithmetic operations over $\bbfF$ need to be implemented. Recall that
an element in $\bbfF$ is represented by a 256-bit number. The na\"ive
implementation for arithmetic operations over $\bbfF$ would require
arithmetic computation over $\bbfZ$. Arithmetic computation for
255-bit integers however is not available in commodity computing
devices as of the year 2017. Long-integer arithmetic has to be carried
out by limbs of 32 or 64 bits depending on the underlying computer
architectures.

In practice, efficient long-integer arithmetic however is more
complicated. Consider subtracting a long integer from another. The
na\"ive implementation would simply subtract by limbs, propagate carry
flags, and add the prime number $\varrho$ if necessary. Carry flag
propagation however may induce waiting time on architectures with
multiple arithmetic logic units (ALUs) such as \todo{amd64? check!} 
More importantly, executime time of the na\"ive subtraction varies
when minuend is less than subtrahend. It allows timing attacks and is
insecure. The na\"ive implementation of 255-bit subtraction should
never be used in cryptographic primitives. 
Figure~\ref{figure:dsl:subtraction}
(Section~\ref{section:domain-specific-language}) in fact is an
efficient and secure implementation of 255-bit subtraction for the
AMD64 architecture. Notice that each limb can be computed in
parallel. It also has constant execution time. 

