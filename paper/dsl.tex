

\begin{eqnarray*}
  N & ::= & \dslcode{1}\ |\ \dslcode{2}\ |\ \cdots\\
  Z & ::= & \cdots \ |\ \dslcode{-2}\ |\ \dslcode{-1} \ |\ 0\ |\ 
            \dslcode{1}\ |\ \dslcode{2}\ |\ \cdots\\
  V & ::= & \dslcode{x} \ |\ \dslcode{y} \ |\ \dslcode{z} \ |\ \cdots\\
  E & ::= &  Z \ |\ V \ |\  \dslcode{-}E \ |\ E \dslcode{+} E 
             \ |\ E \dslcode{-} E
             \ |\ E \times E \ |\ \dslcode{Pow} (E, N)
\end{eqnarray*}

\begin{eqnarray*}
  S & ::= & V \leftarrow E 
            \ |\  V, V \leftarrow \dslcode{Split} (E, N)\\
  P & ::= & \epsilon \ |\ S; P
\end{eqnarray*}

\begin{eqnarray*}
  Q & ::= & \top
     \ |\   E = E
     \ |\   E \equiv E \mod N
     \ |\   Q \wedge Q
\end{eqnarray*}

\begin{eqnarray*}
  H & ::= & \cond{Q} P \cond{Q}
\end{eqnarray*}


\begin{figure}
  \centering
  \[
  \begin{array}{lclcl}
    \begin{array}{rcl}
    \textmd{1:} && \dslcode{r}_0 \leftarrow \dslcode{x}_0; \\
    \textmd{2:} && \dslcode{r}_1 \leftarrow \dslcode{x}_1; \\
    \textmd{3:} && \dslcode{r}_2 \leftarrow \dslcode{x}_2; \\
    \textmd{4:} && \dslcode{r}_3 \leftarrow \dslcode{x}_3; \\
    \textmd{5:} && \dslcode{r}_5 \leftarrow \dslcode{x}_4; \\
    \end{array}
    &\hspace{.05\textwidth}&
    \begin{array}{rcl}
    \textmd{6:} && 
      \dslcode{r}_0 \leftarrow \dslcode{r}_0 + \dslcode{4503599627370458}; \\
    \textmd{7:} &&
      \dslcode{r}_1 \leftarrow \dslcode{r}_1 + \dslcode{4503599627370494}; \\
    \textmd{8:} &&
      \dslcode{r}_2 \leftarrow \dslcode{r}_2 + \dslcode{4503599627370494}; \\
    \textmd{9:} &&
      \dslcode{r}_3 \leftarrow \dslcode{r}_3 + \dslcode{4503599627370494}; \\
    \textmd{10:} && 
      \dslcode{r}_4 \leftarrow \dslcode{r}_4 + \dslcode{4503599627370494};\\
    \end{array}
    &\hspace{.05\textwidth}&
    \begin{array}{rcl}
    \textmd{11:} && \dslcode{r}_0 \leftarrow \dslcode{r}_0 - \dslcode{y}_0; \\
    \textmd{12:} && \dslcode{r}_1 \leftarrow \dslcode{r}_1 - \dslcode{y}_1; \\
    \textmd{13:} && \dslcode{r}_2 \leftarrow \dslcode{r}_2 - \dslcode{y}_2; \\
    \textmd{14:} && \dslcode{r}_3 \leftarrow \dslcode{r}_3 - \dslcode{y}_3; \\
    \textmd{15:} && \dslcode{r}_4 \leftarrow \dslcode{r}_4 - \dslcode{y}_4;
    \end{array}
  \end{array}
  \]
  \caption{Subtraction \dslcode{sub}$(\dslcode{x}_0, \dslcode{x}_1, 
    \dslcode{x}_2, \dslcode{x}_3, \dslcode{x}_4, \dslcode{y}_0,
    \dslcode{y}_1, \dslcode{y}_2, \dslcode{y}_3, \dslcode{y}_4)$}
  \label{figure:dsl:subtraction}
\end{figure}

Figure~\ref{figure:dsl:subtraction} gives a simple yet real
implementation of subtraction over $\bbfGF(\myprime)$. 
In the figure, a number in $\bbfGF(\varrho)$ 
is represented by five 51-bit unsigned integers. The variables
$\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2, \dslcode{x}_3,
\dslcode{x}_4$ for instance represent 
$\mathit{radix51}(\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2,
\dslcode{x}_3, \dslcode{x}_4) \defn
\dslcode{x}_0 + 2^{51} \dslcode{x}_1 + 2^{102} \dslcode{x}_2 +
2^{153} \dslcode{x}_3 + 2^{204} \dslcode{x}_4$. The result of
subtraction is stored in the variables $\dslcode{r}_0, \dslcode{r}_1,
\dslcode{r}_2, \dslcode{r}_3, \dslcode{r}_4$. 
Given $0 \leq \dslcode{x}_0,$ $\dslcode{x}_1,$ $\dslcode{x}_2,$
$\dslcode{x}_3,$ $\dslcode{x}_4,$ $\dslcode{y}_0,$ $\dslcode{y}_1,$
$\dslcode{y}_2,$ $\dslcode{y}_3,$ $\dslcode{y}_4 < 2^{51}$, 
the specification of the program is therefore
\[
\begin{array}{c}
\cond{\top}\\
\dslcode{sub}(\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2,
  \dslcode{x}_3, \dslcode{x}_4, \dslcode{y}_0, \dslcode{y}_1,
  \dslcode{y}_2, \dslcode{y}_3, \dslcode{y}_4)\\
\cond{\mathit{radix}(\dslcode{x}_0, \dslcode{x}_1, \dslcode{x}_2,
\dslcode{x}_3, \dslcode{x}_4) -
\mathit{radix51}(\dslcode{y}_0, \dslcode{y}_1, \dslcode{y}_2,
\dslcode{y}_3, \dslcode{y}_4)
\equiv
\mathit{radix51}(\dslcode{r}_0, \dslcode{r}_1, \dslcode{r}_2,
\dslcode{r}_3, \dslcode{r}_4)
\mod \myprime
}.
\end{array}
\]

Note that the variables $\dslcode{r}_i$'s are added with constants
after they are initizlied with $\dslcode{x}_i$'s but before
$\dslcode{y}_i$'s are subtracted from them. It is not hard to see that
$2\myprime = \mathit{radix51} (4503599627370458,$ $4503599627370494,$
$4503599627370494,$ $4503599627370494,$ $4503599627370494)$
after tedious computation. Hence $\mathit{radix51}(\dslcode{r}_0,$
$\dslcode{r}_1,$ $\dslcode{r}_2,$ $\dslcode{r}_3,$ $\dslcode{r}_4)$ $=$
$\mathit{radix51}(\dslcode{x}_0,$ $\dslcode{x}_1,$ $\dslcode{x}_2,$
$\dslcode{x}_3,$ $\dslcode{x}_4)$ $+$ $2 \myprime $ $-$
$\mathit{radix51}(\dslcode{y}_0,$ $\dslcode{y}_1,$ $\dslcode{y}_2,$
$\dslcode{y}_3,$ $\dslcode{y}_4)$ $\equiv $
$\mathit{radix51}(\dslcode{x}_0,$ $\dslcode{x}_1,$ $\dslcode{x}_2,$
$\dslcode{x}_3,$ $\dslcode{x}_4)$ $-$
$\mathit{radix51}(\dslcode{y}_0,$ $\dslcode{y}_1,$ $\dslcode{y}_2,$
$\dslcode{y}_3,$ $\dslcode{y}_4)$ $\mod \myprime $. The program in
Figure~\ref{figure:dsl:subtraction} is correct. The reason for
adding constants is to prevent underflow. If the constants were not
added, the subtraction in lines~11 to 15 could give negative and hence
incorrect results. Indeed, characteristics of large Galois fields are
regularly exploited in cryptographic programs for correctness and
efficiency. Our domain specific language can easily model such
specialized programming techniques and is most suitable for low-level
cryptographic programs.
